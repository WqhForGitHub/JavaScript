```javascript
a = 2;

var a;

console.log(a); // 2
```

实际上会进行如下处理：

```javascript
var a;

a = 2;

console.log(a); // 2
```



```javascript
console.log(a); // undefined                                                           

var a = 2;
```

实际上会进行如下处理：

```javascript
var a;

console.log(a);

a = 2;
```

总结：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。当你看到 var a = 2，可能会认为这是一个声明。但实际上 JavaScript 实际上会将其看成两个声明：var a 和 a = 2。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。



+ 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。

```javascript
foo();

function foo() {
  console.log(a); // undefined
  
  var a = 2;
}
```

实际上会进行如下处理：

```javascript
function foo() {
  var a;

  console.log(a); // undefined

  a = 2;
}

foo();
```



+ 函数表达式却不会被提升

```javascript
foo(); // 不是 ReferenceError, 而是 TypeError

var foo = function bar(){
  // ...
}
```

```javascript
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar(){
  // ...
};
```



实际代码经过提升后，实际上会被理解为以下形式：

```javascript
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function(){
  var bar 
}
```



+ 函数优先：函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。

```javascript
foo();

var foo;

function foo() {
  console.log(1);
}

foo = function() {
  console.log(2);
};
```

这段代码会被引擎理解为如下形式：

```javascript
function foo(){
  console.log(1);
}

foo(); // 1

foo = function() {
  console.log(2);
}
```

总结：var foo 尽管出现在 function foo() ... 的声明之前，但它是重复声明（因此被忽略了），因为函数声明会被提升到普通变量之前。



+ 尽量重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

```javascript
foo(); // 3

function foo() {
  console.log(1);
}

var foo = function() {
  console.log(2);
};

function foo() {
  console.log(3);
}
```



+ 避免在块内部声明函数

```javascript
foo();

var a = true;
if(a) {
  function foo() { console.log("a"); }
} else {
  function foo() { console.log("b"); }
}
```



<h2 id="ObQzp"></h2>
