<h3 id="SdSWz">4.5 宽松相等和严格相等</h3>
正确区别：==允许在相等比较中进行强制类型转换，而 === 不允许。

1. 字符串和数字之间的相等比较

```javascript
var a = 42;
var b = "42";

a === b; // false
a == b; // true

a == ToNumber(b);
```

总结：字符串转化为数字，再进行比较。



2. 其他类型和布尔类型之间的相等比较

```javascript
var a = "42";
var b = true;

a == b; // false
```

总结：布尔类型转换为数字。首先先将 true 转换为 1， 然后 "42" == 1, 再变成 42==1，结果为 false。



3. null 和 undefined 之间的相等比较

```javascript
var a = null;
var b;

a == b; // true
a == null; // true
b == null; // true

a == false; // false
b == false; // false
a == ""; // false
b == ""; // false
a == 0; // false
b == 0; // false
```



4. 对象和非对象之间的相等比较

```javascript
var a = 42;
var b = [42];

a == b; // true
```

总结："42" == 42 , 然后变成 42==42，最后二者相等。



```javascript
var a = "abc";
var b = Object(a); // 和 new String(a)一样

a === b; // false
a == b; // true
```

总结： a==b 结果为 true, 因为 b 通过 ToPrimitive 进行强制类型转换。



```javascript
var a = null;
var b = Object(a); // 和 Object 一样
a == b; // false

var c = undefined; 
var d = Object(c); // 和 Object 一样
c == d; // false

var e = NaN;
var f = Object(e); // 和 new Number(e) 一样
e == f; // false
```

总结：NaN == NaN 返回 false



5. 少见的情况

```javascript
Number.prototype.valueOf = function() {
  return 3;
};

new Number(2) == 3; // true
```

总结：Number(2) 涉及 ToPrimitive 强制类型转换，因此会调用 valueOf()。

```javascript
var i = 2;

Number.prototype.valueOf = function() {
  return i++;
};

var a = new Number(42);

if(a == 2 && a == 3) {
  console.log("Yep, this happened.");
}
```

总结：Number(42) 涉及 ToPrimitive 强制类型转换，因此会调用 valueOf()。



6. 假值得相等比较

```javascript
"0" == null; // false
"0" == undefined; // false
"0" == false; // true -- 
"0" == 0; // true
"0" == ""; // false

false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 
false == ""; // true -- 
false == []; // true -- 
false == {}; // false

"" == null; // false
"" == undefined; // false
"" == NaN; // false
"" == 0; // true -- 
"" == []; // true -- 
"" == {}; // false

0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 
0 == {}; // false
```



7. 极端情况

```javascript
[] == ![]; // true
```

总结：根据 ToBoolean 规则，它会进行布尔值的显式强制类型转换，所以 [] == ![] => []==false => [] ==0 => 0==0;

```javascript
2 == [2]; // true
"" == [null]; // true
0 == "\n"; // true
0 == " "; // true
```



8. 安全运用隐式强制类型转换
+ 如果两边的值中有 true 或者 false, 千万不要使用 ==。
+ 如果两边的值中有 [], ""或者 0，尽量不要使用 ==。

<h3 id="AZsKC">4.6 抽象关系比较</h3>
抽象关系比较分为两个部分：比较双方都是字符串和其他情况。

+ 其他情况：比较双方首先调用 ToPrimitive, 如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。

```javascript
var a = [42];
var b = ["43"];

a < b; // true
b < a; // false
```



+ 字符串情况：则按字母顺序来进行比较

```javascript
var a = ["42"];
var b = ["043"];

a < b; // false
```



```javascript
var a = [4,2];
var b = [0,4,3];

a < b; // false
```

```javascript
var a = {b: 42};
var b = {b: 43};

a < b; // false
a == b; // false
a > b; // false

a <= b; // true 理解为 b < a 的反转
a >= b; // true
```

总结：因为 a 是 [object Object], b 也是 [object Object]，所以按照字母顺序 a < b 并不成立。

```javascript
var a = [42];
var b = "043";

a < b; // false 字符串比较
Number(a) < Number(b); // true 数字比较
```

