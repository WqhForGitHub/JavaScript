<h3 id="sPAHp">[[Prototype]]</h3>
```javascript
var anotherObject = {
  a:2
};

var myObject = Object.create(anotherObject);

for(var k in myObject) {
  console.log("found: " + k)
} 
// found: a

("a" in myObject); // true
```

总结：使用 for - in 遍历对象时原理和查找 [[prototype]] 链类似，任何可以通过原型链访问到（并且是enumerable）的属性都会被枚举。使用 in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）



<h3 id="B5I7n">属性设置和屏蔽</h3>
```javascript
var anotherObject = {
  a:2
};

var myObject = Object.create(anotherObject);

anotherObject.a; // 2
myObject.a; // 2

anotherObject.hasOwnProperty("a"); // true
myObject.hasOwnProperty("a"); // false

myObject.a++; // 隐式屏蔽

anotherObject.a; // 2
myObject.a; // 3

myObject.hasOwnProperty("a"); // true 
```



<h3 id="wQQhY">构造函数</h3>
```javascript
function NothingSpecial() {
  console.log("Don't mind me!");
}

var a = new NothingSpecial(); 
// "Don't mind me!"

a; // {}
```

总结：函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成 "构造函数调用"。



```javascript
function Foo() {}

Foo.prototype = {};

var a1 = new Foo();
a1.constructor === Foo; // false
a1.constructor === Object; // true
```

总结：a1 并没有 .constructor 属性，所以它会委托 [[Prototype]] 链上的 Foo.prototype。但是这个对象也没有 .constructor 属 (不过默认的 Foo.prototype 对象有这个属性)。所以它会继续委托，这次会委托链顶端的 Object.prototype。这个对象有 .constructor 属性，指向内置的 Object 函数。



```javascript
function Foo() {};

Foo.prototype= {};

Object.defineProperty(Foo.prototype, "constructor", {
  enumerable: false,
  writable: true,
  configurable: true,
  value: Foo
});
```



<h3 id="JOM4k">原型继承</h3>
```javascript
function Foo() {
  this.name = name;
}

Foo.prototype.myName = function() {
  return this.name;
};

function Bar(name, label) {
  Foo.call(this, name);
  this.label = label;
}

Bar.prototype = Object.create(Foo.prototype);

Bar.prototype.myLabel = function() {
  return this.label;
};

var a = new Bar("a", "obj.a");

a.myName(); // "a"
a.myLabel(); // "obj a"
```

 

